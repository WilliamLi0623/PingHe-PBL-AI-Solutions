# -*- coding: utf-8 -*-
"""“Python Assignment 6: Text Procession.ipynb”的副本

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S9KmYS4d01BTQwNwnUPJB-pZv94ay6Fs

# Python Assignment 7: Text Procession (40 pts)

## Question 1.1 Make Gerund (10 pts)
`make_gerund(s)`: which adds **'ing'** to the end of the given string **s** and returns this new word. If **s** already ends with **'ing'**, add an **'ly'** to the end of **s** instead. You may assume that s is at least 3 characters long.
"""

def make_gerund(s):
  if(s[-1]=='g' and s[-2]=='n' and s[-3]=='i'):
    s+='ly';
  else:
    s+='ing';
  return s;

# Test Your Function Here
print(make_gerund('play'))
print(make_gerund('playing'))

"""## Question 1.2 Tridromes (10 pts)
We say that a word is a *tridrome* if the first three letters of the word are the same as the last three letters of the word (and appear in the same order). All *tridromes* must be at least 6 letters long. For example, ENTERTAINMENT, MURMUR, and UNDERGROUND are tridromes. 

Write a function `is_tridrome(word)` that returns **True** if a word is a *tridrome* and **False** otherwise.
"""

def is_tridrome(word):
  if(len(word)<6):return False;
  elif(word[0:3]!=word[-3:]):return False;
  return True;

# Test
print(is_tridrome("tomorrow"))
print(is_tridrome("ENTERTAINMENT"))

"""## Question 1.3 Peaceful Words (10 pts)
We say that a word is peaceful if its letters are in alphabetical order. For example, ALMOST, CHIPS, DIRTY, FIRST, and HOST are all peaceful words. (It's ok to have two of the same letters be next to each other)

Write a function `is_peaceful(word)` that returns **True** if a word is peaceful and **False** otherwise.
"""

def is_peaceful(word):
  for i in (1,len(word)-1):
    if(ord(word[i])<ord(word[i-1])):return False;
  return True;

# Test
print(is_peaceful("ALMOST"))
print(is_peaceful("BYE"))

"""## Question 1.4 - String encoding (10 pts)
A simple means for trying to compress text with many repeated characters is to use
something known as run-length encoding. The idea is that rather than representing every
character in a string explicitly, we instead simply have each character immediately
followed by a digit which denotes how many times that character should be repeated. For
example, the string 'B4' would represent the string 'BBBB' as the character B is to be
repeated 4 times. Similarly, the string 'm1e2t1' would represent 'meet', as the character
m is to be repeated 1 time, followed by the character e which is to be repeated 2 times,
followed by the character t is to be repeated 1 time. Thus, the general format for runlength encoded strings is a series of pairs, where each pair contains a single character
followed immediately by a single digit (1 through 9 only, the digit will never be 0). The
digit denotes the number of consecutive occurrences of the character immediately before
it in the encoded string.


Your job is to write a function named expand_encoded_string that takes as a parameter a called encoded, which is a string
representing the run-length encoded text, and returns a string which is the expanded version
of the text.

For example, if you call:
`expand_encoded_string('B1o2k2e2p1e1r1!3')`
your function should return the string:
`"'Bookkeeper!!!'`

"""

# Define the function expand_encoded_string here

def expand_encoded_string(encoded):
  tmp="";
  for i in range(len(encoded)):
    if(ord(encoded[i])<ord('0') or ord(encoded[i])>ord('9')):
      tmp1=int(encoded[i+1]);
      for j in range(tmp1):tmp+=(encoded[i]);
  return tmp;

# Test your function here

result = expand_encoded_string('B4')
print(result)      # should print: BBBB

result = expand_encoded_string('m1e2t1')
print(result)      # should print: meet

result = expand_encoded_string('B1o2k2e2p1e1r1!3')
print(result)      # should print: Bookkeeper!!!